->> Segment Tree Lazy Propagation
->> complexity - make_tree(n log n) + update_tree(log n) + query(log n)
->> Source: Safayet Blog

const int N = 1e5;

int arr[N];

struct info {
  int sum, prop;
} node[N * 4];

void make_tree(int parent, int left, int right) {
  if (left == right) {
    node[parent].sum = arr[left];
    return;
  }
  int lc = parent * 2;
  int rc = parent * 2 + 1;
  int mid = (left + right) / 2;
  make_tree(lc, left, mid);
  make_tree(rc, mid + 1, right);
  node[parent].sum = node[lc].sum + node[rc].sum;
}

void update_tree(int parent, int left, int right, int i, int j, int x) {
  if (i > right || j < left) return;
  if (left >= i && right <= j) {
    node[parent].prop += x;
    node[parent].sum += (right - left + 1) * x;
    return;
  }
  int lc = parent * 2;
  int rc = parent * 2 + 1;
  int mid = (left + right) / 2;
  update_tree(lc, left, mid, i, j, x);
  update_tree(rc, mid + 1, right, i, j, x);
  node[parent].sum = node[lc].sum + node[rc].sum + node[parent].prop * (right - left + 1);
}

int query(int parent, int left, int right, int i, int j, int carry = 0) {
  if (i > right || j < left) return 0;
  if (left >= i && right <= j) {
    return node[parent].sum + carry * (right - left + 1);
  }
  int lc = parent * 2;
  int rc = parent * 2 + 1;
  int mid = (left + right) / 2;
  int a = query(lc, left, mid, i, j, carry + node[parent].prop);
  int b = query(rc, mid + 1, right, i, j, carry + node[parent].prop);
  return a + b;
}

int main() {
  ios :: sync_with_stdio(false);
  cin.tie(0);
  int n; cin >> n;
  for (int i = 1; i <= n; i++) {
    cin >> arr[i];
  }
  make_tree(1, 1, n);
  update_tree(1, 1, n, 3, 5, 4);
  query(1, 1, n, 1, 10);
}
